# Set log output to minimal information [Default value: TRUE]
Quiet = FALSE

# Control log output of communication tags [Default value: FALSE]
TagTrace = FALSE

# Control of solving status log [Default value: FALSE]
LogSolvingStatus = FALSE

# Control output of tasks transfer log [Default value: FALSE]
LogTasksTransfer = FALSE

# Control checkpointing functionality [Default value: FALSE]
Checkpoint = FALSE

# Control deterministic mode [Default value: FALSE]
Deterministic = FALSE

# Control output of statistics to stdout [Default value: FALSE]
StatisticsToStdout = FALSE

# Control dynamic adjustment of notification interval time [Default value: FALSE]
DynamicAdjustNotificationInterval = FALSE

# Control output of ParaParams: 0 - no output, 1 - output only non-default values, 2 - output non-default values with comments, 3 - output all values, 4 - output all values with comments [Default value: 4]
OutputParaParams = 4

# Control ramp-up phase process: 0 - normal process, 1 - racing process, 2 - rebuild tree after racing [Default value: 2]
RampUpPhaseProcess = 2

# Set notification synchronization strategy: 0 - always synchronize, 1 - collect in every iteration, 2 - no synchronization [Default value: 0]
NotificationSynchronization = 0

# Set interval between notifications from active solver of its solvers status to LoadCoordinator. [Default: 1.0][0.0, DBL_MAX]
NotificationInterval = 1

# Time limit for computation. -1.0 means no time limit. [Default: -1.0] [-1.0, DBL_MAX]
TimeLimit = -1

# Time interval between checkpoints. [Default: 3600.0] [5.0, DBL_MAX]
CheckpointInterval = 3600

# Time until start of generation of final checkpointing files. When this parameter is specified, TimeLimit is ignored. -1.0 means no specification. [Default: -1.0] [-1.0, DBL_MAX]
FinalCheckpointGeneratingTime = -1

# Path for temporary files [Default: /tmp/]
TempFilePath = "/tmp/"

# Filename for tag trace log [Default: std::cout]
TagTraceFileName = "std::cout"

# Path to solving statuses log [Default: ./]
LogSolvingStatusFilePath = "./"

# Path to tasks transfer log [Default: ./]
LogTasksTransferFilePath = "./"

# Path to output solution [Default: ./]
SolutionFilePath = "./"

# Path to checkpoint files [Default: ./]
CheckpointFilePath = "./"

# Path racing parameter configuration files. "" means to use default racing set. [Default: ""]
RacingParamsDirPath = ""

# Control output of subtree log [Default value: FALSE]
LogSubtreeInfo = FALSE

# Control output of tabular solving statues [Default value: TRUE]
OutputTabularSolvingStatus = TRUE

# Control output of tabular solving status using deterministic time (only valid when Deterministic = TRUE)  [Default value: FALSE]
DeterministicTabularSolvingStatus = FALSE

# Use root node cuts in ParaInstance, that is, the instance data for solvers has the root node cuts of the original problem. [Default value: FALSE]
UseRootNodeCuts = FALSE

# Transfer local cuts generated by a solver as diffSubproblem info. [Default value: TRUE]
TransferLocalCuts = TRUE

# Transfer conflict cuts generated by a solver as diffSubproblem info. [Default value: FALSE]
TransferConflictCuts = FALSE

# Transfer conflicts generated by a solver as diffSubproblem info. [Default value: TRUE]
TransferConflicts = TRUE

# Transfer branching status generated by a solver as diffSubproblem info. [Default value: TRUE]
TransferBranchStats = TRUE

# Transfer var-value status generated by a solver as diffSubproblem info. [Default value: FALSE]
TransferVarValueStats = FALSE

# Transfer benders cuts generated by a solver as diffSubproblem info. [Default value: FALSE]
TransferBendersCuts = FALSE

# Check effect of root node preprocesses. [Default value: FALSE]
CheckEffectOfRootNodePreprocesses = FALSE

# Control whether or not all open nodes are collected to LC after ramp-up. [Default value: TRUE]
CollectOnce = TRUE

# Control to run for proving or not. [Default value: FALSE]
ProvingRun = FALSE

# Set all parameter values to default after racing. [Default value: FALSE]
SetAllDefaultsAfterRacing = FALSE

# Control if the best primal solution is distributed or not. [Default value: TRUE]
DistributeBestPrimalSolution = TRUE

# Control if light weight root node processing is applied. [Default value: FALSE]
LightWeightRootNodeProcess = FALSE

# Control if racing status branching is applied. [Default value: TRUE]
RacingStatBranching = TRUE

# Control if iterative break down is applied. [Default value: FALSE]
IterativeBreakDown = FALSE

# Control if preprocessing is disabled in LoadCoordinator. [Default value: FALSE (enabled)]
NoPreprocessingInLC = FALSE

# Disable transfer of upper bound to the other solvers in racing. [Default value: FALSE (transfer)]
NoUpperBoundTransferInRacing = FALSE

# Merge nodes at restart or not. [Default value: FALSE]
MergeNodesAtRestart = FALSE

# Control whether or not to NChangeIntoCollectingMode to the number of solvers/2  [Default value: FALSE]
NChangeIntoCollectingModeNSolvers = FALSE

# Enable event weighted deterministiv run (each event has its weight of deterministic time) [Default value: FALSE]
EventWeightedDeterministic = FALSE

# Disable presolving at root node, for distributed memory version this should be set to FALSE  [Default value: FALSE (enable presolving)]
NoSolverPresolvingAtRoot = FALSE

# Disable presolving at root and set default parameter settings: for distributed memory version this should be set to FALSE  [Default value: FALSE (enable presolving)]
NoSolverPresolvingAtRootDefaultSet = FALSE

# Disable aggressive separator settings in racing  [Default value: TRUE]
NoAggressiveSeparatorInRacing = TRUE

# Transfer bound changes not only for branching variables, but for all variables. [Default value: TRUE]
AllBoundChangesTransfer = TRUE

# Disable transfer of all bound changes when the stage is in racing, even if AllBoundChangesTransfer=TRUE [Default value: FALSE]
NoAllBoundChangesTransferInRacing = FALSE

# Break the first subtree [Default value: FALSE]
BreakFirstSubtree = FALSE

# Run to generate initial nodes [Default value: FALSE]
InitialNodesGeneration = FALSE

# Restart racing ramp-up, when primal solution was updated in racing [Default value: FALSE]
RestartRacing = FALSE

# Check gap and absmipgap in LoadCoordinator [Default value: FALSE]
CheckGapInLC = FALSE

# Check solution feasiblity in LoadCoordinator [Default value: FALSE]
CheckFeasibilityInLC = FALSE

# Collecting mode can be controlled on solver side [Default value: FALSE]
ControlCollectingModeOnSolverSide = FALSE

# Clean up run for reducing check-pointing file [Default value: FALSE]
CleanUp = FALSE

# Test dual bound gain in Solver [Default value: FALSE]
DualBoundGainTest = FALSE

# The parallel solver is used only to generate reduced checkpoint files. [Default value: FALSE]
GenerateReducedCheckpointFiles = FALSE

# Output presolved instance. This is useful to verify the instance data at restart [Default value: FALSE]
OutputPresolvedInstance = FALSE

# Communicate tighter bounds of variables in racing. [Default value: TRUE]
CommunicateTighterBoundsInRacing = TRUE

# Keep racing until first feasible solution was found. [Default value: FALSE]
KeepRacingUntilToFindFirstSolution = FALSE

# Allow tree restart in solver [Default value: FALSE]
AllowTreeSearchRestart = FALSE

# Omit infeasible terminations during racing [Default value: FALSE]
OmitInfeasibleTereminationInRacing = FALSE

# In case of racing termination wait for all threads to terminate [Default value: TRUE]
WaitTerminationOfThreads = TRUE

# Number of nodes in LoadCoordinator to decide to change into collecting mode [Default value: 1][0, INT_MAX]
NChangeIntoCollectingMode = 1

# Node transfer mode: 0 - best estimate node transfer, 1 - best bound node transfer [Default value: 1]
NodeTransferMode = 1

# Minimum number of Solvers that can be in collecting mode. [Default value: 1]
MinNumberOfCollectingModeSolvers = 1

# Maximum number of Solvers that can be in collecting mode : -1 - no limit, 0 - half of the number of Solvers, n > 0 - n [Default value: 0]
MaxNumberOfCollectingModeSolvers = 0

# The order to send request messages in collecting mode: -1 - no ordering, 0 - ordered by best dual bound value, 1 - ordered by number of nodes left, 2 - choose alternatively the best bound and the number of nodes orders  [Default value: 0]
SolverOrderInCollectingMode = 0

# Racing ramp-up termination criteria : 0 - stop at the number of nodes left reached, 1 - stop at time limit, 2: - stop at the Solver with the best dual bound value has a certain number of nodes, 3 - adaptive(node first), 4 - adaptive (time first):  [Default value: 4]
RacingRampUpTerminationCriteria = 5

# The number of nodes left in a solver to stop racing : [1, INT_MAX]:  [Default value: 300]
StopRacingNumberOfNodesLeft = 300

# The number of nodes left in the root solver to stop keeping nodes. 0: no keeping nodes : [0, INT_MAX]:  [Default value: 0]
NumberOfNodesKeepingInRootSolver = 0

# The number of nodes left in all solvers to stop generating initial nodes : [1, INT_MAX]:  [Default value: 300]
NumberOfInitialNodes = 300

# The maximum number of seeds for racing parameter set : [1, INT_MAX]:  [Default value: 64]
MaxNRacingParamSetSeed = 64

# The number of variable order tries in racing ramp-up : [1, INT_MAX]:  [Default value: 100]
TryNVariablegOrderInRacing = 100

# The number of branching order tries in racing ramp-up : [1, INT_MAX]:  [Default value: 100]
TryNBranchingOrderInRacing = 100

# The number of evaluation solvers to stop racing. ( -1 stops at all of the solvers, 0 stop at half of the solvers ) : [-1, INT_MAX]:  [Default value: -1]
NEvaluationSolversToStopRacing = -1

# The maximum number of candidates for collecting mode solvers. : [1, INT_MAX]:  [Default value: 10]
NMaxCanditatesForCollecting = 10

# The number of nodes left in a solver to start breaking. : [0, INT_MAX]:  [Default value: 0: no breaking]
NSolverNodesStartBreaking = 0

# The number of nodes left in the system to stop breaking. : [0, INT_MAX]:  [Default value: 0: no breaking]
NStopBreaking = 0

# The number of nodes left in the system to stop breaking. : [1, INT_MAX]:  [Default value: 100]
NTransferLimitForBreaking = 100

# Number of nodes solved less than this value can be a candidate of stop solving mode. The value less than 0 means no stop solving. [Default: 3][-1, INT_MAX]
NStopSolvingMode = 3

# Number of nodes collected once to LC. The value -1 means all. 0 means # solvers * 5. [Default: 0][-1, INT_MAX]
NCollectOnce = -1

# Depth to try presolving in the other solvers. Offset value will be added. The value -1 means no aggressive presolving. [Default: -1][-1, INT_MAX]
AggressivePresolveDepth = -1

# Depth to stop aggressive presolving. This value is only valid for AggressivePresolveDepth > 0. [Default: 8][1, INT_MAX]
AggressivePresolveStopDepth = 8

# Big dual gap subtree handling. 0 - throw away, 1 - send back to LC [Default: 0][0, 1]
BigDualGapSubtreeHandling = 0

# Instance data transfer method. 0 - on memory, 1 - by file, 2 - by original data [Default: 0][0, 2]
InstanceTransferMethod = 0

# Not transfer and keep nodes depth from sub-MIP root less than this value. [Default: -1][-1, INT_MAX]
KeepNodesDepth = -1

# Alternate solving is prohibited when the specified value grater than zero. The number of nodes left is less than the value, alternate solving is performed. [Default: 100][0, INT_MAX]
NoAlternateSolving = 100

# The number of nodes transferred is logged when the specified value grater than zero. The specified value indicates the frequency for the logging. [Default: 0][0, INT_MAX]
NNodesTransferLogging = 0

# The number of idle solvers to terminate forcibly. value < 0 means no termination depending of the number of idle solvers.  [Default: -1][-1, INT_MAX]
NIdleSolversToTerminate = -1

# The number of solvers whoes nodes are collected at the final checkpoint. The value = -1 means all solvers nodes are collected. [Default: 10][-1, INT_MAX]
FinalCheckpointNSolvers = 10

# The number of nodes trying to merge at restart. The value = -1 means that it trys to merge all nodes.. [Default: -1][-1, INT_MAX]
NMergingNodesAtRestart = -1

# How many number of bound changes is needed to merge.  The value = -1 means that it sets automatically. 0 means everything. [Default: -1][-1, INT_MAX]
NBoundChangesOfMergeNode = -1

# Number of nodes, which will not be processed, to keep in checkpoint file. This parameter is only valid in restarting with checkpoint file. [Default: 0][0, INT_MAX]
NNodesToKeepInCheckpointFile = 0

# Maximum number of racing base parameter configurations. File started from 1 to NMaxRacingBaseParameters. [Default: 0][0, 99999]
NMaxRacingBaseParameters = 0

# Number of bound changes need to transfer a branch node. -1 means no restrictions. [Default: -1][-1, 99999]
NBoundChangesForTransferNode = -1

# Omit racing termination until to get the number of incumbent solutions. 1 means that at least one feasible solution is needed. [Default: 0][0, 99999]
OmitTerminationNSolutionsInRacing = 0

# The number of nodes in checkpoint file is eager to break down at restart. 0 means that all nodes. [Default: 0][0, 99999]
NCheckPointNodesBreakDownAtRestrat = 0

# Multiplier mp in collecting mode. When the # of good nodes becomes greater than mp * NChangeIntoCollectingMode, stop collecting [Default value: 2.0][1.0, DBL_MAX]
MultiplierForCollectingMode = 2

# Multiplier mth to determine threshold value. When # of nodes left grater than mth * (meanRootNodeTime/ (meanNodeTime except root)), a Solver starts sending nodes in collecting mode [Default: 1.5][1.0, DBL_MAX]
MultiplierToDetermineThresholdValue = 1.5

# Bound gap_p to identify good nodes, (bound value of a node - best bound value )/ (best bound value ) < gap_p is treated as good nodes. [Default: 0.4][0.0,1.0]
BgapCollectingMode = 0.4

# A Solver in collecting mode becomes out of collecting mode, when (the solver's best dual bound value - g.b.d.b.v )/g.b.d.b.v > gap_p* (MultiplierForBgapCollectingMode) [Default:10.0][1.0, 10.0]
MultiplierForBgapCollectingMode = 10

# A Solver in collecting mode becomes out of collecting mode, when the absolute dual gap to the best solver is grater than this value and the best solver is not in collecting mode (Don't set 0.0)  [Default:1.0][0.0, DBL_MAX]
ABgapForSwitchingToBestSolver = 1

# A solver is stopped and all generated nodes except the root throws away, when ( its local best dual bound value - LC.b.d.b.v ) / LC.b.d.b.v > BgapStopSolvingMode. [Default: 0.33][0.0, 10.0]
BgapStopSolvingMode = 0.33

# The time limit to stop racing. [Default: 720.0] [1.0, DBL_MAX]
StopRacingTimeLimit = 720

# An extending time limit multiplier in case nodes left less than stop-racing number of nodes left. [Default: 50.0] [1.0, DBL_MAX]
StopRacingTimeLimitMultiplier = 50

# The number of nodes left limit multiplier not to collect once.. [Default: 20.0] [1.0, DBL_MAX]
StopRacingNumberOfNodesLeftMultiplier = 3

# Time stays in empty node pool. The limit number of collecting mode solver increase, when node pool stays empty more than this time  [Default: 10.0] [1.0, DBL_MAX]
TimeToIncreaseCMS = 10

# Output tabular solving status log evry this interval time  [Default: 5.0] [0.0, DBL_MAX]
TabularSolvingStatusInterval = 5

# Idle solvers ratio to apply light weight root node process.
# When # of idle solver > this value * # of solvers, it is applied.  [Default: 0.5] [0.0, 1.0]
RatioToApplyLightWeightRootProcess = 0.5

# Multiplier for a target dual bound for breaking.  [Default: 1.03] [1.0, DBL_MAX]
MultiplierForBreakingTargetBound = 1.03

# Fixed variables ration in merging open nodes.  [Default: 0.9] [0.0, 1.0]
FixedVariablesRatioInMerging = 0.9

# Allowable regression ratio of dual bound value in merging.  [Default: 0.0] [0.0, 1.0]
AllowableRegressionRatioInMerging = 0

# Ratio for the number of Solvers that count on the racing ones (The solvers have to notify its status to LC).  [Default: 0.5] [0.0, 1.0]
CountingSolverRatioInRacing = 0.5

# When racing winner has nodes less than (the number of Solvers)*(this value), CollectOnce should be prohibited.  [Default: 0.0] [0.0, DBL_MAX]
ProhibitCollectOnceMultiplier = 0

# The number of nodes transferred is logged when the specified value grater than zero. The specified value indicates the frequency for the logging. [Default: 2.0][-1.0, DBL_MAX]
TNodesTransferLogging = 2

# Frequency to select a node randomly from node pool in LC.  [Default: 0.2][0.0, 1.0]
RandomNodeSelectionRatio = 0.2

# Branch if the dual bound gain less than average of the that multiplied by this value.  [Default: 0.5][0.0, 3.0]
DualBoundGainBranchRatio = 0.5

# Interval time between collecting mode less than this time, increase the number of collecting nodes. Negative value: no dynamic adjust. NOT set 0.0. [Default: 10.0][-1.0, DBL_MAX]
CollectingModeInteraval = 10

# Threshold time to restart in ramp-down phase. -1.0: no restart. Do not set a positive value less than 1.0. [Default: -1.0][-1.0, DBL_MAX]
RestartInRampDownThresholdTime = -1

# Active solvers ratio to restart in ramp-down phase. If the active solvers ratio less than the value keeps until the threshold time, restart. [Default: 0.7][0.01, 0.99]
RestartInRampDownActiveSolverRatio = 0.7

# Threshold time to detect huge inbalance. -1.0: no detect. NOT set 0.0. [Default: -1.0][-1.0, DBL_MAX]
HugeImbalanceThresholdTime = -1

# Active solvers ratio to detect huge inbalance. If the active solvers ratio less than the value keeps until the threshold time, detect huge inbalance. [Default: 0.9][0.01, 0.99]
HugeImbalanceActiveSolverRatio = 0.9

# Node computing time less than this value can be a candidate of stop solving mode. The value less than 0 means no stop solving. [Default: -1][-1.0, DBL_MAX]
TimeStopSolvingMode = -1

# Reduction ratio for no node transfer threshold value. [Default: 1.0][0.0, 1.0]
NoTransferThresholdReductionRatio = 1

# Solver parameter settings file name that is applied at initial presolving in LoadCoordinator. Empty name use default settings. [Default: ]
SolverSettingsForInitialPresolving = ""

# Solver parameter settings file name that is applied at root node solving (including presolving in LC). Empty name use default settings. [Default: ]
SolverSettingsAtRootNode = ""

# Solver parameter settings file name that is applied at all nodes solving except root node. Empty name use default settings. [Default: ]
SolverSettingsExceptRootNode = ""

# Solver parameter settings file name that is applied at racing stage. Empty name use default settings. [Default: ]
SolverSettingsAtRacing = ""

# Indicate if root node solvability is checked before transfer or not. TRUE: root node solvability is checked, FALSE: no check [Default value: FALSE]
RootNodeSolvabilityCheck = FALSE

# Customized to shared memory environment, if it runs on it. [Default value: TRUE]
CustomizedToSharedMemory = TRUE

# Apply distributed local branching. [Default value: FALSE]
LocalBranching = FALSE

# Adding constraint: objective func >= dualBoundValue (This is not a good idea, because it creates many degenerate solutions) : 0 - no adding, 1 - adding to discarded ParaNodes only, 2 - adding always, 3 - adding at warm start [Default value: 0]
AddDualBoundCons = 0

